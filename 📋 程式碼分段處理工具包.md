<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# 📋 程式碼分段處理工具包

這個工具包可以幫您將任何過長的程式碼檔案安全地分割成小段，方便與AI互動，完全不影響原始檔案的功能。

## 🛠️ 通用分段腳本

### 主要腳本：`code_splitter.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
通用程式碼分段處理工具
適用於所有類型的程式碼檔案：CSS, JS, HTML, JSON, Python, Java等
完全不修改原始內容，只進行物理分割
"""

import os
import sys
import argparse
from datetime import datetime
import json

class CodeSplitter:
    def __init__(self, input_file, lines_per_chunk=400, output_dir=None):
        self.input_file = input_file
        self.lines_per_chunk = lines_per_chunk
        self.output_dir = output_dir or f"split_{self.get_base_name()}"
        self.file_extension = os.path.splitext(input_file)[1]
        self.base_name = self.get_base_name()
        
    def get_base_name(self):
        """獲取不含路徑和副檔名的檔案名"""
        return os.path.splitext(os.path.basename(self.input_file))[0]
    
    def create_output_directory(self):
        """創建輸出目錄"""
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            print(f"✅ 已創建輸出目錄: {self.output_dir}")
        else:
            print(f"📁 使用現有目錄: {self.output_dir}")
    
    def read_file(self):
        """讀取原始檔案"""
        try:
            with open(self.input_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            return lines
        except UnicodeDecodeError:
            # 嘗試其他編碼
            try:
                with open(self.input_file, 'r', encoding='gbk') as f:
                    lines = f.readlines()
                print("⚠️ 使用 GBK 編碼讀取檔案")
                return lines
            except:
                with open(self.input_file, 'r', encoding='latin-1') as f:
                    lines = f.readlines()
                print("⚠️ 使用 Latin-1 編碼讀取檔案")
                return lines
    
    def split_file(self):
        """分割檔案"""
        print(f"🔧 開始分割檔案: {self.input_file}")
        
        lines = self.read_file()
        total_lines = len(lines)
        
        if total_lines <= self.lines_per_chunk:
            print(f"⚠️ 檔案只有 {total_lines} 行，無需分割")
            return []
        
        self.create_output_directory()
        
        chunk_files = []
        chunk_num = 1
        
        for i in range(0, total_lines, self.lines_per_chunk):
            chunk_lines = lines[i:i + self.lines_per_chunk]
            
            # 生成分段檔案名
            chunk_filename = f"{self.base_name}_part_{chunk_num:02d}{self.file_extension}"
            chunk_path = os.path.join(self.output_dir, chunk_filename)
            
            # 寫入分段檔案
            with open(chunk_path, 'w', encoding='utf-8') as f:
                f.writelines(chunk_lines)
            
            chunk_info = {
                'filename': chunk_filename,
                'path': chunk_path,
                'lines': len(chunk_lines),
                'start_line': i + 1,
                'end_line': i + len(chunk_lines)
            }
            chunk_files.append(chunk_info)
            
            print(f"📄 已創建: {chunk_filename} (第 {i+1}-{i+len(chunk_lines)} 行，共 {len(chunk_lines)} 行)")
            chunk_num += 1
        
        return chunk_files
    
    def generate_summary(self, chunk_files):
        """生成分割摘要檔案"""
        summary = {
            'original_file': self.input_file,
            'total_lines': sum(chunk['lines'] for chunk in chunk_files),
            'chunks_count': len(chunk_files),
            'lines_per_chunk': self.lines_per_chunk,
            'split_time': datetime.now().isoformat(),
            'chunks': chunk_files
        }
        
        summary_path = os.path.join(self.output_dir, f"{self.base_name}_split_summary.json")
        with open(summary_path, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        
        print(f"📊 已生成摘要檔案: {summary_path}")
        return summary_path
    
    def generate_readme(self, chunk_files):
        """生成說明檔案"""
        readme_content = f"""# {self.base_name} 分段處理說明

## 📋 基本資訊
- **原始檔案**: `{self.input_file}`
- **總行數**: {sum(chunk['lines'] for chunk in chunk_files)} 行
- **分段數量**: {len(chunk_files)} 個
- **每段大小**: 約 {self.lines_per_chunk} 行
- **分割時間**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## 📁 分段檔案清單

| 檔案名 | 行數範圍 | 行數 |
|--------|----------|------|
"""
        for chunk in chunk_files:
            readme_content += f"| `{chunk['filename']}` | {chunk['start_line']}-{chunk['end_line']} | {chunk['lines']} |\n"
        
        readme_content += f"""
## 🤖 AI 互動建議

### 1. 逐個檔案處理
```

請分析以下程式碼片段（來自 {self.base_name}，第 X-Y 行）：
[貼上分段檔案內容]

```

### 2. 說明檔案來源
為了讓 AI 更好理解上下文，請在每次提問時說明：
- 這是來自哪個原始檔案的第幾段
- 檔案的整體功能和用途
- 需要 AI 協助的具體問題

### 3. 重組建議
處理完所有分段後，可以要求 AI 協助重組優化後的程式碼。

## ⚠️ 注意事項
- 原始檔案 `{self.input_file}` 完全未被修改
- 所有分段檔案僅供分析使用
- 如需應用修改，請先備份原始檔案
"""
        
        readme_path = os.path.join(self.output_dir, "README.md")
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)
        
        print(f"📖 已生成說明檔案: {readme_path}")
        return readme_path

def main():
    parser = argparse.ArgumentParser(description='通用程式碼分段處理工具')
    parser.add_argument('input_file', help='要分割的檔案路徑')
    parser.add_argument('-l', '--lines', type=int, default=400, 
                       help='每段的行數 (默認: 400)')
    parser.add_argument('-o', '--output', help='輸出目錄 (默認: split_檔案名)')
    
    args = parser.parse_args()
    
    # 檢查輸入檔案是否存在
    if not os.path.exists(args.input_file):
        print(f"❌ 錯誤: 找不到檔案 '{args.input_file}'")
        sys.exit(1)
    
    # 執行分割
    splitter = CodeSplitter(args.input_file, args.lines, args.output)
    
    try:
        chunk_files = splitter.split_file()
        
        if chunk_files:
            splitter.generate_summary(chunk_files)
            splitter.generate_readme(chunk_files)
            
            print(f"\n🎉 分割完成!")
            print(f"📁 輸出目錄: {splitter.output_dir}")
            print(f"📄 分段數量: {len(chunk_files)}")
            print(f"💡 請查看 README.md 了解如何使用分段檔案")
        
    except Exception as e:
        print(f"❌ 分割過程中發生錯誤: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
```


## 📖 操作手冊

### 🚀 快速開始

#### 1. 基本使用

```bash
# 分割 CSS 檔案（默認每段 400 行）
python code_splitter.py Dashboard.css

# 分割 JavaScript 檔案，每段 300 行
python code_splitter.py main.js -l 300

# 指定輸出目錄
python code_splitter.py data.json -o my_output_folder
```


#### 2. 常見檔案類型的建議設定

| 檔案類型 | 建議每段行數 | 指令範例 |
| :-- | :-- | :-- |
| CSS | 400-500 | `python code_splitter.py style.css -l 450` |
| JavaScript | 300-400 | `python code_splitter.py app.js -l 350` |
| HTML | 200-300 | `python code_splitter.py index.html -l 250` |
| JSON | 100-200 | `python code_splitter.py data.json -l 150` |
| Python | 200-300 | `python code_splitter.py main.py -l 250` |

### 📁 輸出結構

執行後會生成以下結構：

```
split_Dashboard/
├── Dashboard_part_01.css    # 第 1-400 行
├── Dashboard_part_02.css    # 第 401-800 行
├── Dashboard_part_03.css    # 第 801-1200 行
├── ...
├── Dashboard_split_summary.json  # 分割摘要（機器可讀）
└── README.md                     # 使用說明（人類可讀）
```


### 🤖 與 AI 互動的最佳實踐

#### 1. 提問模板

```markdown
# 給 AI 的標準提問格式

**檔案資訊**: Dashboard.css 第 801-1200 行（共 3200 行中的第 3 段）
**檔案功能**: 網站儀表板的樣式表，包含狀態卡片、毛玻璃效果等

**請協助**: [具體問題，如：重構、優化、除錯等]

**程式碼**:
```

[貼上分段檔案內容]

```
```


#### 2. 分析策略

- **第一輪**: 逐段了解功能和結構
- **第二輪**: 識別問題和改進點
- **第三輪**: 獲取具體的修改建議
- **第四輪**: 討論重組和整合方案


### 🔧 進階功能腳本

#### 檔案重組腳本：`code_merger.py`

```python
#!/usr/bin/env python3
"""
將分段處理後的檔案重新合併
用於應用 AI 建議的修改
"""

import os
import json
import glob

def merge_split_files(split_dir):
    """合併分段檔案"""
    
    # 讀取摘要檔案
    summary_files = glob.glob(os.path.join(split_dir, "*_split_summary.json"))
    if not summary_files:
        print("❌ 找不到分割摘要檔案")
        return
    
    with open(summary_files[0], 'r', encoding='utf-8') as f:
        summary = json.load(f)
    
    # 找到所有分段檔案
    base_name = os.path.splitext(os.path.basename(summary['original_file']))[0]
    extension = os.path.splitext(summary['original_file'])[1]
    
    pattern = os.path.join(split_dir, f"{base_name}_part_*{extension}")
    chunk_files = sorted(glob.glob(pattern))
    
    if not chunk_files:
        print("❌ 找不到分段檔案")
        return
    
    # 合併內容
    merged_content = ""
    for chunk_file in chunk_files:
        with open(chunk_file, 'r', encoding='utf-8') as f:
            merged_content += f.read()
    
    # 生成合併後的檔案
    merged_filename = f"{base_name}_merged{extension}"
    merged_path = os.path.join(split_dir, merged_filename)
    
    with open(merged_path, 'w', encoding='utf-8') as f:
        f.write(merged_content)
    
    print(f"✅ 已生成合併檔案: {merged_path}")
    print(f"📊 總行數: {merged_content.count(chr(10)) + 1}")

if __name__ == '__main__':
    import sys
    if len(sys.argv) != 2:
        print("使用方法: python code_merger.py <分段目錄>")
        sys.exit(1)
    
    merge_split_files(sys.argv[1])
```


### 🎯 使用場景範例

#### 場景 1：分析大型 CSS 檔案

```bash
# 1. 分割檔案
python code_splitter.py Dashboard.css -l 400

# 2. 與 AI 逐段分析
# （使用生成的分段檔案與 AI 互動）

# 3. 如需合併修改後的檔案
python code_merger.py split_Dashboard
```


#### 場景 2：處理複雜的 JavaScript 專案

```bash
# 分割主要檔案
python code_splitter.py main.js -l 300 -o js_analysis

# 分割工具檔案  
python code_splitter.py utils.js -l 200 -o js_analysis
```


### ⚠️ 故障排除

#### 常見問題與解決方案

| 問題 | 解決方案 |
| :-- | :-- |
| 編碼錯誤 | 腳本會自動嘗試 UTF-8、GBK、Latin-1 編碼 |
| 權限不足 | 確保有寫入權限，或使用 `sudo`（Linux/Mac） |
| 檔案過小 | 小於設定行數的檔案不會分割，會給出提示 |
| 輸出目錄衝突 | 使用 `-o` 參數指定不同的輸出目錄 |

#### 檢查腳本：`check_splitter.py`

```python
#!/usr/bin/env python3
"""
檢查分段處理工具的環境和依賴
"""

import os
import sys

def check_environment():
    """檢查執行環境"""
    print("🔍 檢查執行環境...")
    
    # 檢查 Python 版本
    if sys.version_info < (3, 6):
        print("❌ 需要 Python 3.6 或更新版本")
        return False
    else:
        print(f"✅ Python 版本: {sys.version}")
    
    # 檢查必要模組
    required_modules = ['os', 'sys', 'argparse', 'datetime', 'json', 'glob']
    for module in required_modules:
        try:
            __import__(module)
            print(f"✅ 模組 {module}: 可用")
        except ImportError:
            print(f"❌ 模組 {module}: 缺失")
            return False
    
    print("🎉 環境檢查通過！")
    return True

if __name__ == '__main__':
    check_environment()
```


### 💡 Pro Tips

#### 1. 批次處理

```bash
# 處理多個檔案的批次腳本（Windows .bat）
@echo off
for %%f in (*.css *.js *.html) do (
    python code_splitter.py "%%f" -l 400
)

# Linux/Mac 批次腳本 (.sh)
#!/bin/bash
for file in *.css *.js *.html; do
    python code_splitter.py "$file" -l 400
done
```


#### 2. 與版本控制整合

```bash
# 將分段目錄加入 .gitignore
echo "split_*/" >> .gitignore

# 或者只追蹤摘要檔案
git add split_*/README.md
git add split_*/*_split_summary.json
```

這個工具包讓您能夠安全、高效地處理任何過長的程式碼檔案，完全不影響原始檔案的功能，同時提供最佳的 AI 互動體驗！

